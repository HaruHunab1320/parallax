/**
 * @primitive map
 * @category transformation
 * @description Transform each item in a collection
 * @confidence minimum-of-all
 */

// Map with confidence tracking
export const map = (transformer) => {
  return (items) => {
    if (!Array.isArray(items)) {
      return { error: "Input must be an array" } ~> 0.0
    }
    
    if (items.length === 0) {
      return [] ~> 1.0
    }
    
    const results = []
    let minConfidence = 1.0
    
    for (const item of items) {
      const transformed = transformer(item)
      results.push(transformed)
      
      // Track minimum confidence
      const confidence = ~transformed
      if (confidence < minConfidence) {
        minConfidence = confidence
      }
    }
    
    return results ~> minConfidence
  }
}

// Filter with confidence
export const filter = (predicate) => {
  return (items) => {
    if (!Array.isArray(items)) {
      return { error: "Input must be an array" } ~> 0.0
    }
    
    const results = []
    let minConfidence = 1.0
    
    for (const item of items) {
      const shouldInclude = predicate(item)
      const predicateConfidence = ~shouldInclude
      
      if (shouldInclude) {
        results.push(item)
      }
      
      // Track confidence of decisions
      minConfidence = Math.min(minConfidence, predicateConfidence, ~item)
    }
    
    return results ~> minConfidence
  }
}

// FlatMap with confidence
export const flatMap = (transformer) => {
  return (items) => {
    if (!Array.isArray(items)) {
      return { error: "Input must be an array" } ~> 0.0
    }
    
    const results = []
    let minConfidence = 1.0
    
    for (const item of items) {
      const transformed = transformer(item)
      const confidence = ~transformed
      
      if (Array.isArray(transformed)) {
        results.push(...transformed)
      } else {
        results.push(transformed)
      }
      
      minConfidence = Math.min(minConfidence, confidence)
    }
    
    return results ~> minConfidence
  }
}