/**
 * @primitive reduce
 * @category aggregation
 * @description Reduce array to single value with confidence tracking
 * @confidence accumulator-based
 */

// Reduce with confidence propagation
export const reduce = (reducer, initial) => {
  return (items) => {
    if (!Array.isArray(items) || items.length === 0) {
      return initial
    }
    
    let accumulator = initial
    let minConfidence = ~initial
    
    for (const item of items) {
      // Apply reducer
      accumulator = reducer(accumulator, item)
      
      // Track minimum confidence
      const itemConf = ~item
      const accConf = ~accumulator
      minConfidence = Math.min(minConfidence, itemConf, accConf)
    }
    
    return accumulator ~> minConfidence
  }
}

// Map-reduce pattern
export const mapReduce = (mapper, reducer, initial) => {
  return (items) => {
    if (!Array.isArray(items)) {
      return { error: "Input must be an array" } ~> 0.0
    }
    
    // Map phase with confidence tracking
    const mapped = items.map(item => mapper(item))
    
    // Reduce phase
    return reduce(reducer, initial)(mapped)
  }
}

// Group by with confidence
export const groupBy = (keySelector) => {
  return (items) => {
    if (!Array.isArray(items)) {
      return {} ~> 0.0
    }
    
    const groups = {}
    let minConfidence = 1.0
    
    for (const item of items) {
      const key = keySelector(item)
      const confidence = ~item
      
      if (!groups[key]) {
        groups[key] = []
      }
      
      groups[key].push(item)
      minConfidence = Math.min(minConfidence, confidence)
    }
    
    return groups ~> minConfidence
  }
}