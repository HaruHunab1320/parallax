/**
 * @primitive dependency
 * @category workflow
 * @description Execute tasks with dependency resolution
 * @confidence minimum-critical-path
 */

// DAG execution with topological sort
export const dag = (tasks) => {
  return async (input) => {
    const completed = new Map()
    const inProgress = new Set()
    let minConfidence = 1.0
    
    // Topological sort
    const sorted = topologicalSort(tasks)
    
    for (const taskName of sorted) {
      const task = tasks[taskName]
      
      // Wait for dependencies
      const depResults = []
      for (const dep of (task.depends || [])) {
        if (!completed.has(dep)) {
          return {
            error: `Missing dependency: ${dep}`,
            completed: Array.from(completed.keys())
          } ~> 0.0
        }
        depResults.push(completed.get(dep))
      }
      
      // Execute task with dependency results
      const taskInput = task.mergeDeps ? 
        task.mergeDeps(input, depResults) : 
        input
        
      const result = await task.execute(taskInput)
      completed.set(taskName, result)
      
      minConfidence = Math.min(minConfidence, ~result)
    }
    
    return {
      results: Object.fromEntries(completed),
      order: sorted
    } ~> minConfidence
  }
}

// Checkpoint for long-running workflows
export const checkpoint = (saveState, restoreState) => {
  return (workflow) => {
    return async (input) => {
      // Try to restore from checkpoint
      const restored = await restoreState(input)
      
      if (restored && ~restored > 0.5) {
        console.log("Resuming from checkpoint")
        return workflow(restored)
      }
      
      // Wrap workflow to save checkpoints
      const checkpointed = async (data) => {
        const result = await workflow(data)
        
        // Save successful results
        if (~result > 0.7) {
          await saveState(result)
        }
        
        return result
      }
      
      return checkpointed(input)
    }
  }
}

function topologicalSort(tasks) {
  const visited = new Set()
  const sorted = []
  
  function visit(name) {
    if (visited.has(name)) return
    visited.add(name)
    
    const task = tasks[name]
    if (task.depends) {
      for (const dep of task.depends) {
        visit(dep)
      }
    }
    
    sorted.push(name)
  }
  
  for (const name in tasks) {
    visit(name)
  }
  
  return sorted
}