/**
 * @primitive parallel
 * @category execution
 * @description Execute multiple operations concurrently
 * @confidence propagates-all
 */

import { executeTask } from "../utils/executor.prism"

// Parallel execution primitive
export const parallel = (maxConcurrency) => {
  return (tasks) => {
    // Validate inputs
    if (!Array.isArray(tasks)) {
      return { error: "Tasks must be an array" } ~> 0.0
    }
    
    // Handle empty array
    if (tasks.length === 0) {
      return [] ~> 1.0
    }
    
    // Execute tasks with concurrency limit
    const results = []
    const executing = []
    let index = 0
    
    // Process tasks in batches
    while (index < tasks.length || executing.length > 0) {
      // Start new tasks up to concurrency limit
      while (executing.length < maxConcurrency && index < tasks.length) {
        const taskIndex = index
        const task = tasks[taskIndex]
        
        // Execute task and track promise
        const execution = executeTask(task).then(result => {
          results[taskIndex] = result
          return taskIndex
        })
        
        executing.push(execution)
        index += 1
      }
      
      // Wait for at least one task to complete
      if (executing.length > 0) {
        const completedIndex = await Promise.race(executing)
        executing = executing.filter(e => e !== executing[completedIndex])
      }
    }
    
    // Return results with aggregated confidence
    const minConfidence = results.reduce((min, r) => {
      const conf = ~r
      return conf < min ? conf : min
    }, 1.0)
    
    return results ~> minConfidence
  }
}

// Convenience functions for common concurrency levels
export const parallel5 = parallel(5)
export const parallel10 = parallel(10)
export const parallelUnlimited = parallel(Infinity)