/**
 * @name LoadBalancer
 * @version 1.0.0
 * @description Route requests to the best available agent based on confidence and performance
 * @input {"type": "object", "properties": {"task": {"type": "string"}, "data": {"type": "any"}, "strategy": {"type": "string", "enum": ["confidence", "latency", "availability", "weighted"]}}}
 * @agents {"capabilities": ["any"]}
 * @minAgents 1
 */

// Get routing strategy
strategy = input.strategy || "weighted"

// Get all available agents
availableAgents = parallax.agents.filter(agent => 
  agent.status == "online" && agent.capabilities.length > 0
)

if availableAgents.length == 0 {
  result = {
    error: "No available agents",
    recommendation: "Wait for agents to come online"
  }
  result ~> 0.0
}

// Score agents based on strategy
scoredAgents = availableAgents.map(agent => {
  score = 0
  
  if strategy == "confidence" {
    // Use historical confidence
    score = agent.historicalConfidence || 0.5
  } else if strategy == "latency" {
    // Lower latency is better (inverse)
    avgLatency = agent.metrics.averageLatency || 1000
    score = 1000 / (avgLatency + 1)
  } else if strategy == "availability" {
    // Use success rate as availability metric
    score = agent.metrics.successRate || 0.5
  } else {
    // Weighted strategy combines all factors
    confScore = agent.historicalConfidence || 0.5
    latencyScore = 1000 / ((agent.metrics.averageLatency || 1000) + 1)
    availScore = agent.metrics.successRate || 0.5
    
    // Weighted combination
    score = (confScore * 0.5) + (latencyScore * 0.2) + (availScore * 0.3)
  }
  
  return {
    agent: agent,
    score: score
  }
})

// Sort by score descending
scoredAgents.sort((a, b) => b.score - a.score)

// Select best agent
bestAgent = scoredAgents[0].agent

// Execute task with selected agent
agentResult = bestAgent.analyze(input.task, input.data)
confidence = ~agentResult

// Return result with routing metadata
result = {
  value: agentResult,
  confidence: confidence,
  routing: {
    selectedAgent: bestAgent.id,
    strategy: strategy,
    score: scoredAgents[0].score,
    alternativeAgents: scoredAgents.slice(1, 3).map(s => s.agent.id)
  }
}

result ~> confidence